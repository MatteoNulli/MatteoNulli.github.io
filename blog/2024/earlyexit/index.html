<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Optimizing Predictions: Vocabulary Reduction and Contrastive Decoding in LLMs | Matteo Nulli </title> <meta name="author" content="Matteo Nulli"> <meta name="description" content="Efficiency-focused early exiting, vocabulary pruning, and contrastive decoding for LLM inference"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?7ce8f2c1aff6bcab703baedc06d2bb55"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%F0%9F%8F%80&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://matteonulli.github.io/blog/2024/earlyexit/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Matteo</span> Nulli </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">more </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <script>
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$','$$'], ['\\[','\\]']]
    }
  };
</script> <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script> <div class="post"> <header class="post-header"> <h1 class="post-title">Optimizing Predictions: Vocabulary Reduction and Contrastive Decoding in LLMs</h1> <p class="post-meta"> Created in November 26, 2024 </p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a> ¬† ¬∑ ¬† <a href="/blog/tag/inference-optimisation"> <i class="fa-solid fa-hashtag fa-sm"></i> Inference-Optimisation</a> ¬† <a href="/blog/tag/efficiency"> <i class="fa-solid fa-hashtag fa-sm"></i> Efficiency</a> ¬† <a href="/blog/tag/llms"> <i class="fa-solid fa-hashtag fa-sm"></i> LLMs</a> ¬† <a href="/blog/tag/early-exiting"> <i class="fa-solid fa-hashtag fa-sm"></i> Early-Exiting</a> ¬† <a href="/blog/tag/contrastive-decoding"> <i class="fa-solid fa-hashtag fa-sm"></i> Contrastive-Decoding</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h5 id="ka-abdel-sadek--m-nulli--j-velja--j-vincenti--g-desimini">K.A. Abdel Sadek *, <strong>M. Nulli</strong> *, J. Velja *, J. Vincenti *, G. Desimini</h5> <h6 id="university-of-amsterdam-uva-bosch-delta-lab-krueger-ai-safety-lab-kasl">University of Amsterdam, UvA-Bosch Delta Lab, Krueger AI Safety Lab (KASL)</h6> <h6 id="----"> <img src="https://upload.wikimedia.org/wikipedia/commons/1/17/Uva%C2%AEmerken_ENG.png" alt="University of Amsterdam" height="24"> ¬† <img src="https://ivi.fnwi.uva.nl/uvaboschdeltalab/images/logo.png" alt="UvA-Bosch Delta Lab" height="24">¬† <img src="https://www.kasl.ai/wp-content/uploads/2023/10/kasl-main-1.png" alt="KASL" height="24">¬†</h6> <h6 id="-paper---blogpost---code">üìÑ <a href="https://arxiv.org/abs/2410.18952" rel="external nofollow noopener" target="_blank">Paper</a> | üìù <a href="https://matteonulli.github.io/blog/2024/earlyexit/" rel="external nofollow noopener" target="_blank">Blogpost</a> | üßë‚Äçüíª <a href="https://github.com/joanvelja/Confidently_Exiting/blob/main/" rel="external nofollow noopener" target="_blank">Code</a> </h6> <h6 id="accepted-to-neurips-efficient-natural-language-and-speech-processing"><em>Accepted to NeurIPS, Efficient Natural Language and Speech Processing</em></h6> <h6 id="equal-contribution">*Equal Contribution</h6> <hr> <script>
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['\\[', '\\]']],
    },
    svg: { fontCache: 'global' }
  };
</script> <script id="MathJax-script" async="" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"> </script> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"> <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script> <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body, { delimiters: [ {left: '$$', right: '$$', display: true}, {left: '\\[', right: '\\]', display: true}, {left: '$', right: '$', display: false}, {left: '\\(', right: '\\)', display: false} ], // keep default ignore list so code/pre are skipped });"></script> <h2 id="introduction">Introduction</h2> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <a id="mainfigure"></a> <figure> <picture> <img src="/assets/img/nips_earlyexit2.jpeg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Figure 1: <b> Presenting the paper at NeurIPS.</b> From left to right, Karim Abdel Sadek, Jort Vincenti, Joan Velja and Matteo Nulli. </div> <p>Recent advancements in Large Language Models (LLMs) have significantly improved performance across various Natural Language Processing (NLP) tasks (<a href="#bert-pre-training-2019">Devlin et al., 2019</a>; <a href="#language-models-few-shot-2020">Brown et al., 2020</a>; <a href="#scaling-language-models-2021">Rae et al., 2021</a>; <a href="#using-deepspeed-megatron-2022">Smith et al., 2022</a>; <a href="#palm-scaling-2023">Chowdhery et al., 2023</a>). Efforts at improving the capabilities of these models have revolved around scaling the number of parameters and data (<a href="#scaling-laws-2020">Kaplan et al., 2020</a>; <a href="#traning-compute-optimal-2022">Hoffmann et al., 2022</a>). However, the substantial computational load presents a practical challenge during inference, particularly in resource-constrained applications. To address this issue, Early-Exiting mechanisms (<a href="#branchynet-2016">Teerapittayanon et al., 2016</a>; <a href="#right-tool-2020">Schwartz et al., 2020</a>; <a href="#leebert-2021">Zhu, 2021</a>; <a href="#model-depth-analysis-2021">Simoulin &amp; Crabb√©, 2021</a>; <a href="#fast-robust-early-exiting-2023">Bae et al., 2023</a>) have been proposed, thus reducing the inference time without significantly compromising performance. This approach is crucial because while scaling model architectures is beneficial during training, the same amount of compute may not be necessary at inference time for every input, especially for simpler tasks (<a href="#transformer-key-value-memories-2021">Geva et al., 2021</a>; <a href="#transformer-promoting-concepts-2022">2022</a>). By enabling intermediate layer decoding, Early Exiting offers a promising solution to balance computational efficiency and model accuracy, ensuring that LLMs remain practical and effective in diverse application scenarios.</p> <p>We analyze the early exiting paradigm for LLMs, conducting a preliminary analysis covering challenges associated with this framework. First, we study a phenomenon of non-finetuned LMs, where the confidence at early layers is deemed to be high, but where accuracy is not satisfactory, thus resulting in poor calibration (<a href="#reducing-overconfidence-2022">Mielke et al., 2022</a>; <a href="#linguistic-calibration-2024">Band et al., 2024</a>). This gives us grounds to implement some heuristics for the minimum exit layer in our experiments. We repeat the same analysis for fine-tuned models, observing that the phenomena is not as prominent.</p> <p>We first present a method (<strong>Vocabulary Pruning</strong>) for increasing model efficiency while remaining confident in the quality of the resulting predictions. Specifically, drawing from <a href="#confident-adaptive-language-modeling-2022">Schuster et al. (2022)</a>, we modify their Softmax approach, by pruning the vocabulary size across layers. This allows us to speed-up the inference time of our predictions, with a negligible loss in performance. However, in order to offset the decrease in performance, we thus propose within-model <strong>Contrastive Decoding</strong> (<a href="#contrastive-decoding-2023">Li et al., 2023</a>) as an alternative means for confidence.</p> <p>Our methods are validated empirically on different NLP tasks, including text summarization and question answering. Our experiments demonstrate that, combining the two aforementioned approaches, we attain a Pareto improvement with respect to FLOPS efficiency and performance.</p> <h2 id="related-works">Related Works</h2> <p>While the semantic nature of Natural Language is rich, some parts of a sentence often lack variance. In such cases, the number of layers the model has to potentially go through to return the right token is relatively low. Following this intuition, there have been a large number of studies introducing different Early-Exiting frameworks (<a href="#branchynet-2016">Teerapittayanon et al., 2016</a>; <a href="#right-tool-2020">Schwartz et al., 2020</a>; <a href="#model-depth-analysis-2021">Simoulin &amp; Crabb√©, 2021</a>; <a href="#leebert-2021">Zhu, 2021</a>; <a href="#fast-robust-early-exiting-2023">Bae et al., 2023</a>; <a href="#transformer-key-value-memories-2021">Geva et al., 2021</a>; <a href="#transformer-promoting-concepts-2022">2022</a>).</p> <p><a href="#confident-adaptive-language-modeling-2022">Schuster et al., 2022</a> investigates Softmax-based confidence measures. Here, the challenge of early-exiting is addressed by introducing a framework that dynamically allocates computational resources per input and generation time-step. The exiting criterium is based on the difference in probits between the two most probable predicted tokens. This ensures a gain in computational efficiency, without excessive performance degradation.</p> <p><a href="#fast-robust-early-exiting-2023">Bae et al. (2023)</a> introduces the (FREE) Fast and Robust Early Exiting framework. FREE uses a shallow-deep module to compute the computational path, hence determining the portion of layers used. Alternatively, <a href="#class-exclusion-2024">Wang et al. (2024)</a> propose a class-based early-exiting strategy. This method leverages the use of intermediate layer features to exclude part of the tokens, allowing later layers to focus on a reduced subset of potential tokens.</p> <p>Contrastive Decoding (<a href="#contrastive-decoding-2023">Li et al., 2023</a>) is a technique proposed to reduce unwanted behaviors in LLMs such as hallucinations, repetition, and incoherence. The method employs two models, a smaller one called <i>amateur</i>, and a larger one called <i>expert</i>. They both perform auto-regressive text generation on the same data, and the final predicted token is selected based on the output difference between the predictions of the expert and amateur. However, employing two LLMs is highly inefficient, both in terms of memory and compute. Alternative methods have been proposed, which employ the contrastive decoding scheme, without the necessity of using two models. An example of such work is the idea of Auto-Contrastive Decoding (<a href="#auto-contrastive-decoding-2023">Gera et al., 2023</a>). The authors show how contrasting outputs of different layers within the same model can benefit text generation outputs. The study shows that predictions of shallow layers can help those of deeper ones to attain better results. Other studies have adapted this technique to different tasks such as reducing hallucination in LLMs (<a href="#dola-contrasting-layers-2024">Chuang et al., 2024</a>). Our proposed contrastive decoding techniques are based on both <a href="#auto-contrastive-decoding-2023">Gera et al. (2023)</a> and <a href="#dola-contrasting-layers-2024">Chuang et al. (2024)</a> and adapted to the aforementioned early-exiting framework of <a href="#confident-adaptive-language-modeling-2022">Schuster et al. (2022)</a>.</p> <h2 id="preliminaries-and-experimental-setting">Preliminaries and Experimental Setting</h2> <h3 id="transformer-architecture">Transformer Architecture</h3> <p>The Transformer network, introduced by <a href="#attention-is-all-you-need-2017">Vaswani et al. (2017)</a>, is structured into $L$ layers, each comprising two distinct sublayers: the Multi-Head Attention (MHA) layer and the Feed-Forward Network (FFN) layer. Within this framework, updates to the residual stream for a subsequent prediction are carried out via the following recursive formula:</p> <p align="center"> \[ h^\ell_t = \text{Transformer}^\ell(h^{\ell-1}_t) \] </p> <p>where $\ell$ represents each layer from 1 to $L$, and $h_t^0$ denotes the output of the embedding layer $\mathbf{W_E}$. The embedding layer $\mathbf{W_E} \in \mathbb{R}^{d_{\text{vocab}} \times d_{\text{model}}}$, transforms the tokens $y_{1:t}$ having size $d_{\text{vocab}}$, into dense vector representations sized $d_{\text{model}}$.</p> <p>After processing through the $L$-th layer, the final prediction for the next token, $\hat{x}_{t+1}$, is produced by</p> <p align="center"> \[ p(\hat{x}_{t+1} \mid x_{&lt; t+1}) = \text{softmax}(\textbf{W}_L h^L_{t}) \] </p> <p>where</p> <p align="center"> \[ \textbf{W}_L \in \mathbb{R}^{d_{\text{model}} \times d_{\text{vocab}}} \] </p> <p>is the linear classifier of block L responsible for mapping back the output of the FNN at that block from $d_{\text{model}}$ to $d_{\text{vocab}}$.</p> <p>Our approach incorporates an early-exiting strategy, wherein the generation of the next token can occur at any layer $\ell$ if the computed confidence score $c_\ell$ exceeds a specified threshold $\tau$. When an early exit is triggered at layer $\ell$, it necessitates updating the key and value pairs in subsequent layers to ensure proper attention mechanisms for future tokens. To efficiently manage this, a state copying technique is employed, where the hidden states from the early-exited layer i.e. $h_{t+1}^{\ell}$ are duplicated across subsequent layers ($h_{t+1}^i = h_{t+1}^{\ell}$ for every $i$ such that $i = \ell + 1, ‚Ä¶ , L$). This process maintains computational efficiency and model performance, even in compact - for today‚Äôs standards - model configurations like T5.</p> <h3 id="experimental-setting">Experimental Setting</h3> <p>In this section, we introduce the experimental setting used in both <a href="#methodology">‚ÄúMethodology‚Äù</a> and <a href="#experiments">‚ÄúExperiments‚Äù</a>. We evaluate the encoder-decoder T5 model (<a href="#exploring-limits-2020">Raffel et al., 2020</a>) on two different datasets and two different downstream tasks:</p> <ul> <li>Stanford Question Answering Dataset (SQuAD) (<a href="#squad-2016">Rajpurkar et al., 2016</a>): over 100k annotated data, 10k of which used for evaluation.</li> <li>SamSum (<a href="#samsum-corpus-2019">Gliwa et al., 2019</a>): a human-annotated dataset for abstractive Summarization with more than 800 samples in the Validation set.</li> </ul> <p>Each dataset has its own evaluation metric. Question Answering on SQuAD and Summarization on SamSum will be evaluated via F1 and Rouge-L scores respectively.</p> <p>Additionally, we compare the performance and effects of our proposed methods on:</p> <ul> <li>Pre-trained-only version of T5, from <a href="https://huggingface.co/google-t5/t5-large" target="_blank" rel="noopener noreferrer">t5-large</a>,</li> <li>Fine-tuned version of T5, <a href="https://huggingface.co/jvelja/t5-squad" target="_blank" rel="noopener noreferrer">t5-squad</a>, <a href="https://huggingface.co/jvelja/t5-samsum" target="_blank" rel="noopener noreferrer">t5-samsum</a>. Both are fine-tuned on the corresponding training dataset.</li> </ul> <p>Our code is heavily based and builds on top of the publicly available codebase <a href="https://github.com/raymin0223/fast_robust_early_exit" target="_blank" rel="noopener noreferrer"> fast-robust-early-exit</a> (<a href="#fast-robust-early-exiting-2023">Bae et al., 2023</a>).</p> <h2 id="methodology">Methodology</h2> <h3 id="early-exiting-via-the-softmax-approach">Early Exiting via the Softmax Approach</h3> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <a id="figure-1"></a> <figure> <picture> <img src="/assets/img/early_exit/softmax_shrink.jpeg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> <b>Figure 1:</b> Softmax Pruning approaches: illustration of (1) <i>fixed</i> and (2) <i>decaying</i> pruning methods for token importance preservation. (3) <i>Adaptive</i> decaying not illustrated. </div> <p>Our first approach (<a href="#figure-1">Figure 1</a>) aims to improve a limitation of the Softmax response method introduced by <a href="#confident-adaptive-language-modeling-2022">Schuster et al. (2022)</a>. We denote the final output of layer $\ell$ as</p> <p align="center"> $\textbf{v}^\ell = \text{Softmax}(\textbf{W}_\ell h^{\ell}_{t})$ </p> <p>The so-called confidence measure is computed as the difference between the top two values of the probits vector $\textbf{v}$, at each layer $\ell$. We denote this measure as $c_{t+1}^{\ell}$. Let us define an early-exit threshold $\tau_{t+1}^{\ell}$ at each layer. If our confidence measure exceeds the early exit-threshold,</p> \[c_{t+1}^{\ell} \geq \tau_{t+1}^{\ell}\] <p>the model exits early, providing us with the prediction for the next token computed at layer $\ell$. Otherwise, it continues by going into the next Transformer block. However, the matrix multiplication inside Softmax, i.e., $\mathbf{W_\ell} h_{t}^{\ell}$ is computationally expensive, especially when iterated over multiple layers. The exact number of Floating Point Operations (FLOPs) for the above corresponds to $d_{\text{model}} \times d_{\text{vocab}} \times L$. Hence, by pruning the vocabulary size at the first layer from $d_{\text{vocab}}$ to $k$, the number of computations required will reduce to $d_{\text{model}} \times k \times L$.</p> <p>Recall that $\mathbf{W_\ell} \in \mathbb{R}^{d_{\text{vocab}} \times d_{\text{model}}}$, where $d_{\text{vocab}} \approx 32000$ is our vocabulary size, and $d_{\text{model}}$ is equal to the size of the last hidden representation of our FFN. Both parameters are on a scaling upward trend in SOTA architectures. We argue that most of these computations are redundant, and potentially not necessary for some tasks. In <a href="#figure-2">Figure 2</a>, we show the boxplots for the rank of the final predicted token at each layer, across not fine-tuned and fine-tuned models, for two different datasets. The main takeaway from these images is that the final predicted token is often already highly ranked from the first few layers of our model. This behavior is more explicit in Figures <a href="#figure-2b">2b</a> and <a href="#figure-2d">2d</a>, where we use fine-tuned models on our downstream tasks. On the other hand, confidence alone can be a deceiving measure. LLMs can be overconfident in the first layers, causing the model to exit prematurely. Our desiderata is for the model to be confident at the same time when its prediction has a high accuracy, that is, to be calibrated. However, we interestingly note that such behavior is rarely observed at early layers. In Figures <a href="#figure-3">3</a> and <a href="#figure-4">4</a>, we see the accuracy and the confidence across each layer. The model in the first layers presents an anomalously high confidence, while its performance is still poor. Early exiting only based on the Softmax response would result in bad performance. We decide to set a minimum exit layer parameter $j$, which forces the model to consider exiting only after this layer. Note that this parameter is highly dependent on the model and dataset one experiments on. For fine-tuned models for example, one expects this parameter to be smaller.</p> <p>Motivated by these findings, we introduce three additional modifications to the Softmax response approach.</p> <p><strong>Softmax response via fixed vocabulary pruning</strong> After the minimum early exit layer $j$, we prune $\textbf{W}_{j+1}$, retaining its top-k tokens in the new unembedding matrix. We define the size of the new pruned matrix as</p> <p align="center"> $$ \large \tilde{\textbf{W}}_{j+i} \in \mathbb{R}^{d_{\text{model}} \times k}, \quad \textrm{for} \quad i = 1, \ldots, L-j \quad \textrm{and} \quad k \ll d_{\text{vocab}} $$ </p> <p>The size is kept fixed to $k$ for all subsequent layers. Theoretically, calculating the ratio between the original number of computations required in the original approach and ours, we get</p> <p align="center"> $$ \large \frac{d_{\text{model}} \times d_{\text{vocab}} \times L}{d_{\text{model}} \times k \times (L - j) + d_{\text{model}}\times d_{\text{vocab}} \times j} $$ </p> <p>which corresponds to an approximate efficiency gain in the order of</p> <p align="center"> $$ \large \mathcal{O}\left(\frac{d_{\text{vocab}}}{k} \times (L-j)\right) $$ </p> <p><strong>Softmax response via decaying vocabulary pruning</strong></p> <p>As one can note from <a href="#figure-2">Figure 2</a>, the rank of the predicted token smoothly decreases across layers. Similarly, we start by pruning the $\textbf{W}_{j+1}$ matrix, given a minimum early exit layer $j$. We retain its top $k$-tokens, obtaining</p> <p align="center"> $$ \large \tilde{\textbf{W}}_{j+i} \in \mathbb{R}^{k \times d_{\text{model}}} $$ </p> <p>Now, instead of keeping the reduced matrix size fixed, we further prune it at every successive layer. Given $\tilde{\textbf{W}}_{j+i}$ of size $k_1$, we prune it at layer $j+i+1$ to a reduced matrix of size $k_2$, where</p> <p align="center"> $$ \large k_2 = \max\left( k^*, \frac{k_1}{1 + \frac{k_1 - k^*}{k^*} \cdot \frac{j + i}{\text{num\_layers}}} \right) $$ </p> <p>$k^*$ here indicates a lower bound on the size $\tilde{\textbf{W}}_{j+i+1}$ can reach. The function we define has been chosen based on <a href="#figure-2a">Figure 2a</a>, hence to be robust against the worst-case scenario. It approximates the decay in the ranking of the top-k token in that case. The efficiency gain is even more prominent than in the case of fixed pruning.</p> <p><strong>Softmax response via adaptive vocabulary pruning</strong></p> <p>It can be seen in Figures <a href="#figure-3">3</a> and <a href="#figure-4">4</a> that, after a few blocks, the confidence and the F1 score of each layer are highly correlated. Together with <a href="#figure-2">Figure 2</a>, this poses a basis for an approach where the amount of retained top-k tokens at each layer is adapted to the confidence at the previous one. We propose the following:</p> <p align="center"> $$ \large k^\ell = \text{vocab\_size} \times (1 - \text{confidence}^{\ell - 1} \times \text{scaling_factor}) $$ </p> <p>Where $k^{\ell}$ is the amount of retained tokens at layer $\ell$, $vocab_size$ is the size of the full vocabulary, $\text{confidence}^{\ell - 1}$ is the confidence at layer $\ell - 1$, <strong><em>scaling_factor</em></strong> is a coefficient that is introduced to avoid retaining 0 tokens in case of confidence = 1. For simplicity, this has been set to 0.9 during our experiments.</p> <p>To summarize, our final predicted token is often highly ranked across all layers. Due to this, pruning the vocabulary matrix allows us to reduce the amount of computations at each block, discarding only irrelevant tokens. While we may potentially trade-off some performance, this further speeds up the runtime of our model, allowing us to obtain considerable efficiency gains.</p> <div id="figure-2" class="row mt-3"> <div class="col-sm mt-3 mt-md-0 text-center"> <a id="figure-2a"></a> <figure> <picture> <img src="/assets/img/early_exit/boxplot_topk_rank_evalsquad_google-t5_t5-large.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="caption"> <b>Figure 2a:</b> Non fine-tuned T5-Large model, SQuAD Dataset</div> </div> <div class="col-sm mt-3 mt-md-0 text-center"> <a id="figure-2b"></a> <figure> <picture> <img src="/assets/img/early_exit/boxplot_topk_rank_evalsquad_jvelja_t5-squad.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="caption"> <b>Figure 2b:</b> Fine-tuned T5-Large model, SQuAD Dataset</div> </div> </div> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0 text-center"> <a id="figure-2c"></a> <figure> <picture> <img src="/assets/img/early_exit/boxplot_top1_rank_evalsamsum_google-t5_t5-large.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="caption"> <b>Figure 2c:</b> Non fine-tuned T5-Large model, SamSum Dataset</div> </div> <div class="col-sm mt-3 mt-md-0 text-center"> <a id="figure-2d"></a> <figure> <picture> <img src="/assets/img/early_exit/boxplot_topk_rank_evalsquad_jvelja_t5-squad.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="caption"> <b>Figure 2d:</b> Fine-tuned T5-Large model, SamSum Dataset</div> </div> </div> <div class="caption"> <b>Figure 2:</b> Boxplots of the rank of final predicted token at each layer, across 2 different models and 2 different datasets. </div> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0 text-center"> <a id="figure-3"></a> <figure> <picture> <img src="/assets/img/early_exit/conf_metric_squad_google_t5.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="caption"> <b>Figure 3:</b> Confidence vs F1 accuracy. T5-base model, SQuAD dataset</div> </div> <div class="col-sm mt-3 mt-md-0 text-center"> <a id="figure-4"></a> <figure> <picture> <img src="/assets/img/early_exit/conf_metric_squad_tuned.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="caption"> <b>Figure 4:</b> Confidence vs F1 accuracy. Fine-Tuned model, SQuAD dataset</div> </div> </div> <h3 id="measuring-confidence-via-contrastive-decoding">Measuring Confidence Via Contrastive Decoding</h3> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <a id="figure-5"></a> <figure> <picture> <img src="/assets/img/early_exit/IMG_0311.JPG" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> <b>Figure 5:</b> Dynamic Contrastive Decoding: illustration of how we leverage <i>Contrastive Decoding</i> within model layers. </div> <p>The second approach (<a href="#figure-5">Figure 5</a>) is inspired by <a href="#contrastive-decoding-2023">Li et al. (2023)</a>. We propose to apply their framework to address one of the limitations of <a href="#confident-adaptive-language-modeling-2022">Schuster et al., 2022</a>. Namely, as introduced in previous sections, the Softmax response approach relies on a static notion of confidence, which depends only on the probability distribution computed at the current layer. Such approach may ignore the evolution of the probits‚Äô magnitudes across the model.</p> <p>By contrasting the outputs of smaller LMs with larger ones, Contrastive Decoding (CD) accounts for the difference in representations computed by amateur and mature layers. The core goal of this method is to refine the output distribution by filtering through the lens of larger models, retaining only their superior linguistic predictions. The original implementation involves the use of two models in parallel, returning the log-ratio between the probits $p_{\text{EXP}}$ of a large LM - called the expert - and the probits $p_{\text{AMA}}$ of a small LM - called the amateur.</p> <p>Naturally, this captures the dynamical change of the token‚Äôs distribution when computed at different heights of the Attention‚Äôs stack.</p> <p>Following <a href="#contrastive-decoding-2023">Li et al. (2023)</a>, we first implement the CD adaptive plausibility constraint, $\nu_{\text{head}}(x_{&lt; t})$, defined as:</p> <p align="center"> $$ \large \nu_{\text{head}}(x_{&lt; t}) = \{x_t \in V : p_{\text{EXP}}(x_t|x_{&lt; t}) \geq \alpha \cdot \underset{x'_t \in V}theme (p_{\text{EXP}}(x'_t|x_{&lt; t}))\} $$ </p> <p> where $V$ is our vocabulary. </p> <p>It‚Äôs important to recognize that smaller LMs, despite their limitations, do reliably capture basic elements of English grammar, such as subject-verb agreement. Applying the CD objective indiscriminately could penalize these correct linguistic behaviors, leading to false negatives. It might also erroneously reward implausible token choices, resulting in false positives. To address these potential pitfalls, we incorporate the plausibility constraint $\nu_{\text{head}}$ into our framework. Given a preceding context $x_{&lt; t}$, this constraint selects a subset of plausible next tokens, out of the vocabulary $V$, whose probabilities are above a threshold. The threshold is a fraction $\alpha$ of the max probability token in the vocabulary. We set the hyperparameter $\alpha \in[0, 1]$ to 0.1, as done by <a href="#contrastive-decoding-2023">Li et al. (2023)</a>. Borrowing from <a href="#auto-contrastive-decoding-2023">Gera et al. (2023)</a>, the contrastive objective, called Log Contrastive Difference (LCD), is defined as:</p> \[\large p_{\text{LCD}}(x_t | x_{&lt; t}) = \text{Softmax}\left(\log \frac{p_{\text{EXP}}(x_t | x_{&lt; t})}{p_{\text{AMA}}(x_t | x_{&lt; t})}\right) \sum_{x_t \in V_{head}(x_{&lt; t})} p_{EXP}(x_t | x_{&lt; t})\] <p>The LCD objective is designed to promote text patterns that are preferred by the expert LMs and discourage those that are typically produced by the amateur LMs. It works in tandem with the plausibility constraint, to ensure that the penalization of amateur behaviors does not disregard grammatically correct and sensible language constructs. The final distribution will be:</p> \[\large p_{\text{DCD}}(x_t | x_{&lt; t}) = \begin{cases} p_{\text{LCD}}(x_t | x_{&lt; t}) &amp; \text{if} \ x_t \in V_{\text{head}}(x_{&lt; t}) \\ p_{\text{EXP}}(x_t | x_{&lt; t}) &amp; \text{otherwise} \end{cases}\] <p>We utilize this defined distribution to compute the new confidence $c^{\ell}_t$. By doing so, we overcome the static nature of the confidence measure usually considered in the Early-Exiting literature.</p> <p>On the other hand, we remind that our approach is based on the use of one single model.</p> <p>Building upon <a href="#auto-contrastive-decoding-2023">Gera et al., 2023</a>, we include their variant of auto-contrastive decoding into our early-exiting framework. Here, $p_{\text{EXP}}$ and $p_{\text{AMA}}$ are respectively proxied by the current layer $\ell$ and by the layer $\lfloor{\frac{\ell}{2}}\rfloor$. This intuition is aligned with findings by <a href="#contrastive-decoding-2019">Elbayad et al. (2019)</a> and <a href="#transformer-key-value-memories-2021">Geva et al. (2021)</a>; <a href="#transformer-promoting-concepts-2022">Geva et al. (2022)</a>. We will refer to this auto-contrastive decoding strategy as ‚ÄúWeighted Contrastive Decoding‚Äù. One question that arises from this idea is the previous layer selection. Clearly, this choice of the amateur layer is very arbitrary.</p> <p>We tackle this problem drawing from <a href="#dola-contrasting-layers-2024">Chuang et al., 2024</a>. The authors suggest selection via distance-in-distribution through Jensen-Shannon Divergence. This way, they claim, it is possible to find the most fit amateur layer. They do so by contrasting the final distribution against a set of candidate possible premature layers. The layer selected as the one with highest JSD w.r.t. the expert one. They also divide the layers into 2 to 4 buckets of $J$ based on the total number of layers, relying on a validation set to choose the best bucket for each task. Our claim is that the bucketing strategy is suboptimal for several reasons. First, it requires task-specific selection, which is undesirable since these models are utilized by end users for open-ended generation. Second, bucketing does not address the implicit bias JSD will have towards the lower layers of the distribution. Earlier representations are necessarily more diverse, since the set of plausible tokens for autoregressive generation gets narrower as one goes deeper into the stack. For this reason, we discount the JSD value between two distributions $i, j$ by the layer distance $\ell_j - \ell_i$. The discounting allows us to capture the layers at which there is a more significant distribution change w.r.t. the one we find ourselves at, thus obtaining a meaningful signal from the chosen contrastive distribution.</p> <p>Consider the current expert layer $\ell$, and set of plausible amateur layer $J = { 2, ‚Ä¶, L-1 }$. The selected layer $m$ is obtained as</p> <p> $$ \large m = \underset{j\in J}{\text{argmax}} \frac{1}{\ell - j} \text{JSD} (p_{\ell}(x_t | x_{&lt; t}),p_{j}(x_t | x_{&lt; t})) $$ </p> <p>To illustrate the above method, in (<a href="#figure-6">Figure 6</a>) we show the JSD contrast on a given sample.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <a id="figure-6"></a> <figure> <picture> <img src="/assets/img/early_exit/jsds.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> <b>Figure 6:</b> Evolution in <i>JSD</i> distribution. T5-model, SQuAD Dataset </div> <p>We will call this technique ‚ÄúJensen-Shannon Divergence (JSD) Contrastive Decoding‚Äù.</p> <p>Finally, to get the best of both worlds, we experiment with a mixed approach between Contrastive Decoding and Softmax pruning. The rationale here is that we can combine the CD confidence measure together with the relevant top-k tokens in the logits we find with the pruning done for the Softmax vocabulary pruning approach.</p> <h2 id="experiments">Experiments</h2> <h3 id="softmax-speed-up">Softmax Speed-Up</h3> <p>In this section, we report the results of the different Softmax vocabulary reductions applied to the $\textbf{W}_{j}$ matrix. The aim is to achieve similar performance with regards to the evaluation metrics, while significantly reducing the amount of FLOPs required. We implement the previously proposed approaches and perform our experiments by building on the available <a href="https://github.com/raymin0223/fast_robust_early_exit" target="_blank" rel="noopener noreferrer"> codebase implementation</a>. The minimum exit layer is based on the lowest confidence level found in <a href="#figure-3">Figure 3</a> and <a href="#figure-4">Figure 4</a>. We run experiments, either with the Fixed or Decaying approaches, as presented in <a href="#early-exiting-via-the-softmax-approach">Section ‚ÄúEarly Exiting via the Softmax Approach‚Äù</a>. We evaluate the models based on their respective performance metrics and the number of floating point operations (FLOPs). The evaluation is conducted for both the Question-Answering (see <a href="#figure-7">Figure 7</a>) and Summarization task (see <a href="#figure-8">Figure 8</a>).</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0 text-center"> <figure> <picture> <img src="/assets/img/early_exit/Final%20Plot%20Squad%20F1.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="caption"> <b>F1 Metric</b> for T5-Large and T5-Finetuned with <i>No</i>, <i>Fixed</i>, or <i>Decaying</i> reduction applied to the matrix</div> </div> <div class="col-sm mt-3 mt-md-0 text-center"> <figure> <picture> <img src="/assets/img/early_exit/Final%20Plot%20Squad%20Flops.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="caption"> <b>FLOPs per sample during confidence estimation</b> for T5-Large and T5-Finetuned with <i>No</i>, <i>Fixed</i>, or <i>Decaying</i> reduction applied to the matrix</div> </div> </div> <div class="caption"> <a id="figure-7"></a><b>Figure 7:</b> Performance on Question-Answering Task: Comparison of model performance in terms of F1 score and the number of FLOPs generated per sample during confidence estimation. The minimum exit layer was set to 7 for T5-Large (which sets <i>k=842</i> for fixed) and 2 for T5-Large Finetuned (which sets <i>k=2781</i> for fixed), with the confidence set to 0.9. The amount of FLOPs represents the average from 100 samples and is only calculated during confidence estimation. <a href="#fast-robust-early-exiting-2023">Bae et al. (2023)</a>. </div> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0 text-center"> <figure> <picture> <img src="/assets/img/early_exit/Final%20Plot%20SamSum%20Rougl.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="caption"> <b>RougeL Metric</b> for T5-Large and T5-Finetuned with <i>No</i>, <i>Fixed</i>, or <i>Decaying</i> reduction applied to the matrix</div> </div> <div class="col-sm mt-3 mt-md-0 text-center"> <figure> <picture> <img src="/assets/img/early_exit/Final%20Plot%20Samsum%20flops.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="caption"> <b>FLOPs per sample during confidence estimation</b> for T5-Large and T5-Finetuned with <i>No</i>, <i>Fixed</i>, or <i>Decaying</i> reduction applied to the matrix</div> </div> </div> <div class="caption"> <a id="figure-8"></a><b>Figure 8:</b> Performance on Summarization Task. Comparison of model performance in terms of ROUGE-L score and the number of FLOPs generated per sample. The minimum exit layer was set to 7 for T5-Large (which sets <i>k=842</i> for fixed) and 2 for T5-Large Finetuned (which sets <i>k=2781</i> for fixed), with the confidence set at 0.9 for both. The amount of FLOPs represents the average from 100 samples and is only calculated during confidence estimation. <a href="fast-robust-early-exiting-2023">Bae et al. (2023)</a>. </div> <p> Both plots display the following trend: similar performance is achieved across the evaluation metrics, but the amount of FLOPs decreases by a factor of 100x. Additionally, comparing Fixed and Decaying reduction, half of the FLOPs are utilized by the latter, which however incurs a 2% loss in performance. This illustrates the trade-off: choosing a smaller $k$ reduces the number of FLOPs but at the cost of a degrading performance. Additionally, due to fine-tuned models exiting at earlier stages, fewer FLOPs are computed overall. However, the same trade-off remains. We set the threshold $\tau^{\ell}_{t}$ required for exiting at 0.9 across all layers. It is important to note that if this value were lowered, our model would exit earlier, hence producing faster but more inaccurate and less confident predictions. </p> <h3 id="contrastive-decoding">Contrastive Decoding</h3> <p>In this section, we analyze the behavior of the two implemented versions of Contrastive Decoding confidence measures, Weighted and Jensen-Shannon Divergence (JSD). The goal of this section is to illustrate the impact of CD on the performance and average early exit of the model.</p> <p>Results from <a href="#figure-9">Figure 9</a> show Weighted contrastive decoding achieving comparable average exit layer with Softmax baseline by (<a href="#confident-adaptive-language-modeling-2022">Schuster et al., 2022</a>), while still retaining almost all the performance. More interesting is the behaviour of JSD, which consistently beats the Softmax baseline. The method is exiting earlier with an average gain of 2.5 blocks, while also achieving higher performance with a 2\% increase over the no-exiting baseline (green dot).</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0 text-center"> <figure> <picture> <img src="/assets/img/early_exit/squadexit.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="caption"> <b>(a)</b> Average exit block across different minimum exit layers</div> </div> <div class="col-sm mt-3 mt-md-0 text-center"> <figure> <picture> <img src="/assets/img/early_exit/squadf1.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="caption"> <b>(b)</b> F1 score across different minimum exit layers</div> </div> </div> <div class="caption"> <a id="figure-9"></a><b>Figure 9:</b> SQuAD Average Exit and F1. Results are reported on t5-large non-finetuned model on SQuAD dataset. Due to time and compute constraints, the results displayed are computed on 100 samples. </div> <p>Evaluation on SamSum dataset, <a href="#figure-10">Figure 10</a>, shows notable results. While Weighted Contrastive Decoding is on par with the Softmax baseline, the JSD confidence measure is exiting earlier on average, with a 2.9 block gain against Softmax (red line). Additionally, JSD is attaining an approximate 10\% increase in Rouge-L performance if setting the minimum exit-layer to 17.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0 text-center"> <figure> <picture> <img src="/assets/img/early_exit/sam_avg.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="caption"> <b>(a)</b> Average exit block across different minimum exit layers</div> </div> <div class="col-sm mt-3 mt-md-0 text-center"> <figure> <picture> <img src="/assets/img/early_exit/samsum_intermediate.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="caption"> <b>(b)</b> Rouge-L score across different minimum exit layers</div> </div> </div> <div class="caption"> <a id="figure-10"></a><b>Figure 10:</b> SamSum Average Exit and Rouge-L. Results are reported on t5-large non-finetuned model on SamSum dataset. Due to time and compute constraints, the results displayed are computed on 100 samples. </div> <h3 id="speedup-and-contrastive-decoding">Speedup and Contrastive Decoding</h3> <p>JSD has shown significant performance gains with respect to Softmax and Weighted Contrastive Decoding. In this chapter, we merge JSD with Softmax vocabulary pruning. We then compare the best Softmax vocabulary pruning with Contrastive Decoding against the previously analyzed individual baselines. We show that combining JSD technique with a compute efficient pruning mechanism positively impacts results. We will report the average exit block, the performance score, and the computed FLOPs.</p> <h4 id="best-jsd-pruning-combination">Best JSD Pruning Combination</h4> <p>We perform a series of experiments aimed at understanding the best possible vocabulary pruning method for the best CD confidence measure.</p> <p>Following the argument in <a href="#contrastive-decoding">‚ÄúContrastive Decoding‚Äù</a>, we observe that the model is most performant when the minimum exit layer is selected to be among the latest ones. Keeping this in mind, <a href="#table-1">Table 1</a> shows the average exit layer and score of the model. Both are averaged across these sensible minimum exit layers. We note that combining Adaptive Pruning with JSD beats the performance of JSD combined either with Fixed or Decaying pruning. It also obtains an average gain of 1.2 blocks against Fixed pruning on SamSum. However, JSD+Fixed achieves the highest Rouge-L score in SamSum. Given the considerations above, we choose Adaptive to be the most fitting pruning method to combine with the JSD confidence measure. We defer to Appendix A a series of detailed plots indicating all minimum exit layers in this setting.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/assets/img/early_exit/table1.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> <b id="table-1">Table 1:</b> JSD with pruning. Comparison across different pruning methodologies applied to Jensen-Shannon Divergence (JSD) confidence measure. The values in the table are the mean of exit/performance over 15, 17, 18, 19, 20 as early minimum exit layer ¬± their standard deviation. Due to time and compute constraints, the results displayed are computed on 100 samples. </div> <p>Comparison Across different pruning methodologies applied to Jensen-Shannon Divergence (JSD) confidence measure. The values in the table are the mean of exit/performance over 15, 17, 18, 19, 20 as early minimum exit layer ¬± their standard deviation. Due to time and compute constraints, the results displayed are computed on 100 samples.</p> <h4 id="comparison-with-baseline-models">Comparison with Baseline Models</h4> <p>Given the results of <a href="#speedup-and-contrastive-decoding">‚ÄúSpeedup and Contrastive Decoding‚Äù</a>, together with our analysis of the best minimum exit layer to use in CD, we now compare the most performing pruning method of <a href="#best-jsd-pruning-combination">‚ÄúBest JSD Pruning Combination‚Äù</a> with the baselines from <a href="#contrastive-decoding">‚ÄúContrastive Decoding‚Äù</a> and <a href="#softmax-speedup">‚ÄúSoftmax Speed-Up‚Äù</a>. We set the minimum exit layer at 19 for all the experiments below.</p> <p>In <a href="#softmax-speed-up">‚ÄúSoftmax Speed-Up‚Äù</a> we show the considerable impact the pruning approach has on FLOPs. Similarly, Figures <a href="#figure-10">10</a> and <a href="#figure-11">11</a> show that removing a large number of tokens has a notable effect on compute, reducing it by almost 100 times on SQuAD and 10 on SamSum between JSD baseline and JSD with adaptive pruning. This gap is also more noteworthy when looking at the amount of performance retained. On both fine-tuned and non-finetuned models the decrease in performance between the downstream tasks is never more than 1.5%, with JSD. Lastly, we highlight the difference in results between Figure <a href="#figure-7">7</a>, <a href="#figure-8">8</a>, and Figure <a href="#figure-10">10</a>, <a href="#figure-11">11</a>, due to a higher minimum exit layer selected for the former experiments. However, in both cases, our results are consistent both in trend of terms and performance and FLOPs reduction.</p> <p>In conclusion, combining a vocabulary reduction approach, together with a confidence measure method, allows us to compute considerably fewer FLOPs, while retaining the performance with respect to Softmax and JSD baselines.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0 text-center"> <figure> <picture> <img src="/assets/img/early_exit/squad_f1.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="caption"> <b>F1 Metric</b> for T5-Large and T5-Finetuned with <i>No</i>, <i>Fixed</i>, or <i>Decaying</i> reduction applied to the matrix</div> </div> <div class="col-sm mt-3 mt-md-0 text-center"> <figure> <picture> <img src="/assets/img/early_exit/squad_flops.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="caption"> <b>FLOPs per sample during confidence estimation</b> for T5-Large and T5-Finetuned with <i>No</i>, <i>Fixed</i>, or <i>Decaying</i> reduction applied to the matrix</div> </div> </div> <div class="caption"> <a id="figure-10"></a><b>Figure 10:</b> <b>Performance on Question-Answering Task</b>: Comparison of model performance in terms of F1 score and the amount of FLOPs generated per sample. The minimum exit layer was set to 19 for both T5-Large and T5-Large Finetuned, with the confidence set at 0.9 for both. </div> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0 text-center"> <figure> <picture> <img src="/assets/img/early_exit/rougesamsam.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="caption"> <b>F1 Metric</b> for T5-Large and T5-Finetuned with <i>No</i>, <i>Fixed</i>, or <i>Decaying</i> reduction applied to the matrix</div> </div> <div class="col-sm mt-3 mt-md-0 text-center"> <figure> <picture> <img src="/assets/img/early_exit/sam_flops.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="caption"> <b>FLOPs per sample during confidence estimation</b> for T5-Large and T5-Finetuned with <i>No</i>, <i>Fixed</i>, or <i>Decaying</i> reduction applied to the matrix</div> </div> </div> <div class="caption"> <a id="figure-11"></a><b>Figure 11:</b> Performance on Summarization Task: Comparison of model performance in terms of ROUGE-L score and the amount of FLOPs generated per sample. The minimum exit layer was set to 19 for both T5-Large and T5-Large Finetuned, with the confidence set at 0.9 for both. </div> <h2 id="conclusion-and-future-work">Conclusion and Future Work</h2> <p>In this study, we have explored the application of early exiting strategies within Large Language Models (LLMs) to address the challenge of computational efficiency during inference. Our research integrates traditional early exiting mechanisms with concrete gains in efficiency obtained from vocabulary pruning. Additionally, we apply the idea of Contrastive Decoding to the early exiting setting, showing how this approach can be used as a confidence measure, by imposing a clever heuristic on the choice of the layer to contrast to. Lastly, we combine the aforementioned techniques and demonstrate that we can both retain almost all performance, while still carrying out a considerably lower number of FLOPs during inference. This results in a solution that satisfies both the efficiency and score performances we aimed for.</p> <p>In future work, a natural follow-up is the use of the Contrastive Decoding output as the resulting output to perform the prediction on. Moreover, sensible investigations about the distributional distance and specific interventions on the computation of the contrastive distribution can be considered.</p> <p>On an empirical note, we aim to expand our analysis to include a wider array of tasks - machine translation, open-ended generation, and long context tasks - and evaluation on larger datasets to further validate our proposal. Another limitation is that the overall runtime performance does not always match the improvements seen in FLOPs. This discrepancy is largely due to the hyper-optimization of the PyTorch library, which optimizes matrix multiplications, thereby reducing overall runtime, though it is worth noting that our gains in FLOPs should increase as a function of model scale. Additionally, since we are working with pre-trained tokenizers, reducing the $W_j$ matrix leads to incorrect predictions, necessitating a remapping back to the original vocabulary size. This process introduces an overhead that further worsens runtime, as we are forced to apply the same operation twice (reducing first and then expanding again). Several engineering-reliant optimizations are still possible in this direction, which were not explored due to the previously mentioned constraints. With regards to vocabulary reduction, the function that shrinks the $k$ values is based on the worst-case scenario observed in the data (see <a href="#figure-3">Figure 3</a>). This function could be adjusted depending on both the problem type and the LM employed. For instance, a finetuned model as depicted in <a href="#figure-2b">Figure 2b</a> might benefit from more aggressive shrinkage compared to its non-finetuned counterpart. Additionally, we plan on further refining the integration of the vocabulary pruning method with Contrastive Decoding. We hypothesize that, by leveraging the list of top-k tokens within Contrastive Decoding, we can get rid of the plausibility constraint, overall reducing further reliance on hyperparameter settings and tuning. All these reasons inspire us to further work in this promising direction, and we hope the same applies to the reader.</p> <h3 id="citation">Citation</h3> <p>If you use this work, please cite:</p> <pre><code class="language-bibtex">@misc{vincenti2024dynamicvocabularypruningearlyexit,
      title={Dynamic Vocabulary Pruning in Early-Exit LLMs}, 
      author={Jort Vincenti and Karim Abdel Sadek and Joan Velja and Matteo Nulli and Metod Jazbec},
      year={2024},
      eprint={2410.18952},
      archivePrefix={arXiv},
      primaryClass={cs.CL},
      url={https://arxiv.org/abs/2410.18952}, 
}
@misc{abdelsadek2024optimizing,
  title={Optimizing Predictions: Vocabulary Reduction and Contrastive Decoding in LLMs},
  author={K. A. Abdel Sadek and M. Nulli and J. Velja and J. Vincenti and G. Desimini},
  year={2024},
  url={https://matteonulli.github.io/blog/2025/earlyexit/},
}
</code></pre> <script>
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['\\[', '\\]']]
    },
    svg: {
      fontCache: 'global'
    }
  };
</script> <script id="MathJax-script" async="" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"> </script> <p><strong>References</strong></p> <div id="references-section"> <a id="fast-robust-early-exiting-2023">Bae Sangmin, Ko Jongwoo, Yun Se-Young. (2023). Fast and Robust Early-Exiting Framework for Autoregressive Language Models with Synchronized Parallel Decoding. arXiv preprint arXiv:2310.05424.</a> <a id="linguistic-calibration-2024">Band Neil, Li Xuechen, Ma Tengyu, Hashimoto Tatsunori. (2024). Linguistic Calibration of Language Models. arXiv preprint arXiv:2404.00474.</a> <a id="language-models-few-shot-2020">Brown Tom B, Mann Benjamin, Ryder Nick, Subbiah Melanie, Kaplan Jared, Dhariwal Prafulla, Neelakantan Arvind, Shyam Pranav, Sastry Girish, Askell Amanda, Agarwal Sandhini, Herbert-Voss Ariel, Krueger Gretchen, Henighan Tom, Child Rewon, Ramesh Aditya, Ziegler Daniel M, Wu Jeffrey, Winter Clemens, Hesse Christopher, Chen Mark, Sigler Eric, Litwin Mateusz, Gray Scott, Chess Benjamin, Clark Jack, Berner Christopher, McCandlish Sam, Radford Alec, Sutskever Ilya, Amodei Dario. (2020). Language Models are Few-Shot Learners. arXiv preprint arXiv:2005.14165.</a> <a id="palm-scaling-2023">Chowdhery Aakanksha, Narang Sharan, Devlin Jacob, Bosma Maarten, Mishra Gaurav, Roberts Adam, Barham Paul, Chung Hyung Won, Sutton Charles, Gehrmann Sebastian, and others. (2023). Palm: Scaling language modeling with pathways. Journal of Machine Learning Research, 24(240), 1-113.</a> <a id="dola-contrasting-layers-2024">Chuang Yung-Sung, Xie Yujia, Luo Hongyin, Kim Yoon, Glass James, He Pengcheng. (2024). DoLa: Decoding by Contrasting Layers Improves Factuality in Large Language Models. arXiv preprint arXiv:2309.03883.</a> <a id="bert-pre-training-2019">Devlin Jacob, Chang Ming-Wei, Lee Kenton, Toutanova Kristina. (2019). BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding. In Proceedings of the 2019 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, Volume 1 (Long and Short Papers) (pp. 4171-4186). Minneapolis, Minnesota: Association for Computational Linguistics.</a> <a id="multi-news-2019">Fabbri Alexander R, Li Irene, She Tianwei, Li Suyi, Radev Dragomir R. (2019). Multi-news: A large-scale multi-document summarization dataset and abstractive hierarchical model. arXiv preprint arXiv:1906.01749.</a> <a id="transformer-key-value-memories-2021">Geva Mor, Schuster Roei, Berant Jonathan, Levy Omer. (2021). Transformer Feed-Forward Layers Are Key-Value Memories. In Proceedings of the 2021 Conference on Empirical Methods in Natural Language Processing (pp. 5484-5495). Online and Punta Cana, Dominican Republic: Association for Computational Linguistics.</a> <a id="transformer-promoting-concepts-2022">Geva Mor, Caciularu Avi, Wang Kevin, Goldberg Yoav. (2022). Transformer Feed-Forward Layers Build Predictions by Promoting Concepts in the Vocabulary Space. In Proceedings of the 2022 Conference on Empirical Methods in Natural Language Processing (pp. 30-45). Abu Dhabi, United Arab Emirates: Association for Computational Linguistics.</a> <a id="samsum-corpus-2019">Gliwa Bogdan, Mochol Iwona, Biesek Maciej, Wawer Aleksander. (2019). SAMSum corpus: A human-annotated dialogue dataset for abstractive summarization. arXiv preprint arXiv:1911.12237.</a> <a id="training-compute-optimal-2022">Hoffmann Jordan, Borgeaud Sebastian, Mensch Arthur, Buchatskaya Elena, Cai Trevor, Rutherford Eliza, Casas Diego de Las, Hendricks Lisa Anne, Welbl Johannes, Clark Aidan, and others. (2022). Training compute-optimal large language models. arXiv preprint arXiv:2203.15556.</a> <a id="class-exclusion-2024">Jingcun Wang, Bring Li, Grace Li Zhang. (2024). Early-Exit with Class Exclusion for Efficient Inference of Neural Networks.</a> <a id="scaling-laws-2020">Kaplan Jared, McCandlish Sam, Henighan Tom, Brown Tom B, Chess Benjamin, Child Rewon, Gray Scott, Radford Alec, Wu Jeffrey, Amodei Dario. (2020). Scaling laws for neural language models. arXiv preprint arXiv:2001.08361.</a> <a id="contrastive-decoding-2023">Li Xiang Lisa, Holtzman Ari, Fried Daniel, Liang Percy, Eisner Jason, Hashimoto Tatsunori, Zettlemoyer Luke, Lewis Mike. (2023). Contrastive Decoding: Open-ended Text Generation as Optimization. arXiv preprint arXiv:2210.15097.</a> <a id="faster-depth-adaptive-transformers-2021">Liu Yijin, Meng Fandong, Zhou Jie, Chen Yufeng, Xu Jinan. (2021). Faster depth-adaptive transformers. In Proceedings of the AAAI Conference on Artificial Intelligence (Vol. 35, No. 15, pp. 13424-13432).</a> <a id="reducing-overconfidence-2022">Mielke Sabrina J, Szlam Arthur, Dinan Emily, Boureau Y-Lan. (2022). Reducing conversational agents' overconfidence through linguistic calibration. arXiv preprint arXiv:2012.14983.</a> <a id="contrastive-decoding-improves-reasoning-2023">O'Brien Sean, Lewis Mike. (2023). Contrastive decoding improves reasoning in large language models. arXiv preprint arXiv:2309.09117.</a> <a id="scaling-language-models-2021">Rae Jack W, Borgeaud Sebastian, Cai Trevor, Millican Katie, Hoffmann Jordan, Song Francis, Aslanides John, Henderson Sarah, Ring Roman, Young Susannah, and others. (2021). Scaling language models: Methods, analysis &amp; insights from training gopher. arXiv preprint arXiv:2112.11446.</a> <a id="language-models-unsupervised-multitask-2019">Radford Alec, Wu Jeffrey, Child Rewon, Luan David, Amodei Dario, Sutskever Ilya. (2019). Language models are unsupervised multitask learners. OpenAI blog, 1(8), 9.</a> <a id="squad-2016">Rajpurkar Pranav, Zhang Jian, Lopyrev Konstantin, Liang Percy. (2016). Squad: 100,000+ questions for machine comprehension of text. arXiv preprint arXiv:1606.05250.</a> <a id="exploring-limits-2020">Raffel Colin, Shazeer Noam, Roberts Adam, Lee Katherine, Narang Sharan, Matena Michael, Zhou Yanqi, Li Wei, Liu Peter J. (2020). Exploring the limits of transfer learning with a unified text-to-text transformer. Journal of Machine Learning Research, 21(140), 1-67.</a> <a id="confident-adaptive-transformers-2021">Schuster Tal, Fisch Adam, Jaakkola Tommi, Barzilay Regina. (2021). Consistent accelerated inference via confident adaptive transformers. arXiv preprint arXiv:2104.08803.</a> <a id="confident-adaptive-language-modeling-2022">Schuster Tal, Fisch Adam, Gupta Jai, Dehghani Mostafa, Bahri Dara, Tran Vinh Q, Tay Yi, Metzler Donald. (2022). Confident Adaptive Language Modeling. arXiv preprint arXiv:2207.07061.</a> <a id="right-tool-2020">Schwartz Roy, Stanovsky Gabriel, Swayamdipta Swabha, Dodge Jesse, Smith Noah A. (2020). The right tool for the job: Matching model and instance complexities. arXiv preprint arXiv:2004.07453.</a> <a id="get-to-the-point-2017">See Abigail, Liu Peter J, Manning Christopher D. (2017). Get to the point: Summarization with pointer-generator networks. arXiv preprint arXiv:1704.04368.</a> <a id="model-depth-analysis-2021">Simoulin Antoine, Crabb√© Benoit. (2021). How many layers and why? An analysis of the model depth in transformers. In Proceedings of the 59th Annual Meeting of the Association for Computational Linguistics and the 11th International Joint Conference on Natural Language Processing: Student Research Workshop (pp. 221-228).</a> <a id="using-deepspeed-megatron-2022">Smith Shaden, Patwary Mostofa, Norick Brandon, LeGresley Patrick, Rajbhandari Samyam, Casper Jared, Liu Zhun, Prabhumoye Shrimai, Zerveas George, Korthikanti Vijay, and others. (2022). Using deepspeed and megatron to train megatron-turing nlg 530b, a large-scale generative language model. arXiv preprint arXiv:2201.11990.</a> <a id="branchynet-2016">Teerapittayanon Surat, McDanel Bradley, Kung Hsiang-Tsung. (2016). Branchynet: Fast inference via early exiting from deep neural networks. In 2016 23rd international conference on pattern recognition (ICPR) (pp. 2464-2469). IEEE.</a> <a id="llama2-open-foundation-2023">Touvron Hugo, Martin Louis, Stone Kevin, Albert Peter, Almahairi Amjad, Babaei Yasmine, Bashlykov Nikolay, Batra Soumya, Bhargava Prajjwal, Bhosale Shruti, Bikel Dan, Blecher Lukas, Ferrer Cristian Canton, Chen Moya, Cucurull Guillem, Esiobu David, Fernandes Jude, and others. (2023). Llama 2: Open Foundation and Fine-Tuned Chat Models. arXiv preprint arXiv:2307.09288.</a> <a id="accelerating-llm-inference-2023">Varshney Neeraj, Chatterjee Agneet, Parmar Mihir, Baral Chitta. (2023). Accelerating llm inference by enabling intermediate layer decoding. arXiv preprint arXiv:2310.18581.</a> <a id="attention-is-all-you-need-2017">Vaswani Ashish, Shazeer Noam, Parmar Niki, Uszkoreit Jakob, Jones Llion, Gomez Aidan N, Kaiser ≈Åukasz, Polosukhin Illia. (2017). Attention is all you need. Advances in neural information processing systems.</a> <a id="leebert-2021">Wei Zhu. (2021). LeeBERT: Learned early exit for BERT with cross-level optimization.</a> </div> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/ogllava/">Object-Guided Visual Tokens: Eliciting Compositional Reasoning in Multimodal Language Models</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/cvar/">Perception, Localization, Planning and Control on RAE Robots</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2026/demystifying0/">De-mystifying Multimodal Learning: <br> Enabling Vision in Language Models</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/alma/">Model Compression for Machine Translation in Large Language Models</a> </li> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> ¬© Copyright 2026 Matteo Nulli. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?b7816bd189846d29eded8745f9c4cf77"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">
      window.MathJax = {
        tex: {
          tags: 'ams',
        },
      };
    </script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.min.js" integrity="sha256-rjmgmaB99riUNcdlrDtcAiwtLIojSxNyUFdl+Qh+rB4=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script type="text/javascript">
    /*
     * This JavaScript code has been adapted from the article
     * https://css-tricks.com/reading-position-indicator/ authored by Pankaj Parashar,
     * published on the website https://css-tricks.com on the 7th of May, 2014.
     * Couple of changes were made to the original code to make it compatible
     * with the `al-foio` theme.
     */
    const progressBar = $('#progress');
    /*
     * We set up the bar after all elements are done loading.
     * In some cases, if the images in the page are larger than the intended
     * size they'll have on the page, they'll be resized via CSS to accomodate
     * the desired size. This mistake, however, breaks the computations as the
     * scroll size is computed as soon as the elements finish loading.
     * To account for this, a minimal delay was introduced before computing the
     * values.
     */
    window.onload = function () {
      setTimeout(progressBarSetup, 50);
    };
    /*
     * We set up the bar according to the browser.
     * If the browser supports the progress element we use that.
     * Otherwise, we resize the bar thru CSS styling
     */
    function progressBarSetup() {
      if ('max' in document.createElement('progress')) {
        initializeProgressElement();
        $(document).on('scroll', function () {
          progressBar.attr({ value: getCurrentScrollPosition() });
        });
        $(window).on('resize', initializeProgressElement);
      } else {
        resizeProgressBar();
        $(document).on('scroll', resizeProgressBar);
        $(window).on('resize', resizeProgressBar);
      }
    }
    /*
     * The vertical scroll position is the same as the number of pixels that
     * are hidden from view above the scrollable area. Thus, a value > 0 is
     * how much the user has scrolled from the top
     */
    function getCurrentScrollPosition() {
      return $(window).scrollTop();
    }

    function initializeProgressElement() {
      let navbarHeight = $('#navbar').outerHeight(true);
      $('body').css({ 'padding-top': navbarHeight });
      $('progress-container').css({ 'padding-top': navbarHeight });
      progressBar.css({ top: navbarHeight });
      progressBar.attr({
        max: getDistanceToScroll(),
        value: getCurrentScrollPosition(),
      });
    }
    /*
     * The offset between the html document height and the browser viewport
     * height will be greater than zero if vertical scroll is possible.
     * This is the distance the user can scroll
     */
    function getDistanceToScroll() {
      return $(document).height() - $(window).height();
    }

    function resizeProgressBar() {
      progressBar.css({ width: getWidthPercentage() + '%' });
    }
    // The scroll ratio equals the percentage to resize the bar
    function getWidthPercentage() {
      return (getCurrentScrollPosition() / getDistanceToScroll()) * 100;
    }
  </script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
  
    addBackToTop();
  
</script> <script src="/assets/js/shortcut-key.js"></script> </body> </html>